\section{Tracking}
The first main thread of the program is Track(), which is responsible for using
the NXTCam to track a target. As described in \autoref{SensorTheory}, the camera
is capable of identifying blobs of a given colour, and then output data relating to where
in the cameras field of view the object is located.\nl

Whenever the camera registers a target, it returns data specifying the position
of the blob in the frame. These variables are stored in arrays which can
contain data for 10 different blobs per frame. This can be seen under section 1
in the code exaple in \autoref{TrackVar}. Based on the data recieved over time,
the turret is capable of determining the direction of the target. The variables
for this feature can be found under section 2 in \autoref{TrackVar}.
 
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Variables used on the Track() thread., label = TrackVar, style = nc] 
task Track(){
    int bt[10];
    int bl[10];
    int bc[10];
    int bb[10];
    int br[10];
    int nblobs;

    lib_direction = 0;
    int directionCount = 0;
    int oldBlobCenter = 0;
    int blobCenter = 0;

    int counter = 0;
    dataCounter = 0;
    ...
}
\end{lstlisting}
\end{minipage}

The general behaviour is contained in a while loop seen in \autoref{TrackFirst},
which is executed based on the value of the boolean variable
\textbf{\textit{track}} which defines whether or not the tracking phase is still
ongoing. The behaviour starts on \textbf{line 3} by using the
\textbf{\textit{NXTCam\_GetBlobs}} function to update the blob variables with
the newest frame from the camera. If the number of blobs found was more than
zero, the center of the largest blob (first entry in array) is determined on
\textbf{line 7}. On \textbf{line } he difference in pixels between the blob's
and the cameras centers is stored in \textbf{\textit{temp}} for future
calculations.\nl
  
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = First part of the general tracking behaviour., label = TrackFirst] while(track){
        NXTCam_GetBlobs(CAM_PORT, CAM_ADDR, nblobs, bc, bl, bt, br, bb);
        if(nblobs > 0){
            blobInCam = true;
            counter = 0;
            oldBlobCenter = blobCenter;
            blobCenter = (bl[0] + UpperBound(br[0]))/2;
            int temp = CAM_CENTER - blobCenter;
            Off(ROTATE_MOTOR);
            ...
        }
...
}        
            
\end{lstlisting}
\end{minipage}

After recieving data from the camera, the turret attempts to track the target by
rotating at a speed matching the targets movement. This is shown in
\autoref{DetSpeed}. This operation can first be done after the turret has
determined in which direction the target is moving. Assuming this is the case
(\textbf{lib\_direction!=0}), the GetSpeed function is called in order to
determine the targets speed. This function is shown in \autoref{}. On
\textbf{lines 3-6}, if the determined rotation speed matches the direction in
which the target is moving, the motor is set to rotate at this speed.\nl

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Determine the targets speed at rotate to match it, label = DetSpeed] 
if(lib_direction!=0){
	int tempSpeed = GetSpeed(blobCenter);
	if(tempSpeed > 0 && lib_direction > 0)
		nFwd(ROTATE_MOTOR, tempSpeed);
	else if(tempSpeed < 0 && lib_direction < 0)
		OnFwd(ROTATE_MOTOR, tempSpeed);
}
\end{lstlisting}
\end{minipage}

If the camera is not able to register any targets, a counter is incremented, and
the turrets rotation is stopped. This is shown in \autoref{PurgeData}. This
counter is incremented continually, until its value matches the variable
\textbf{\textit{MAX\_COUNTER\_TO\_PURGE\_DATA}}, after which all values involved
in tracking are reset, such that the turret can start a new tracking phase.

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Reset data and turn off motor is no targets are found., label = PurgeData] 
...
}else{
	blobInCam = false;
    counter++;
    if(counter == MAX_COUNTER_TO_PURGE_DATA){
    	counter = 0;
        data =  NULL;
        dataCounter = 0;
        ResetLibVariables();
        directionCount = 0;
    }
    Off(ROTATE_MOTOR);
}
\end{lstlisting}
\end{minipage}

After recieving data from the camera, the turret uses this data to determine the
direction in which the target is moving, either left or right. This is done by
calling the \textbf{\textit{DetermineDirection}} function as shown in
\autoref{TrackDir}. This is only done once for each tracking phase, which is
indicated by the 'if' statement in \autoref{DetSpeed} where the direction
must not be equal to zero.

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Call DetermineDirection., label = TrackDir]
if(nblobs > 0){
...
}else{
...
}
DetermineDirection(blobCenter, oldBlobCenter, directionCount);
\end{lstlisting}
\end{minipage}

When the \textbf{\textit{DetermineDirection}} method is called, it checks
whether or not a direction has already been determined. Whenever a blob is
registered by the camera, it is determined in what direction the blob has
moved. This is done on \textbf{lines 3-7} where the center of the
current blob is compared to the old one. When the blob moves in a given
direction \textbf{\textit{directionCount}} is either incremented or decremented.
When this variable reaches a certain positive/negative threshold, the direction
is determined.

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Determine the targets direction., label = DeterDir]
void DetermineDirection(int center, int oldCenter, int &directionCount){
	if(lib_direction == 0){
		if(center > oldCenter){
    		directionCount++;
		}
    	else if (center < oldCenter) {
    		directionCount--;
   		}
    	if(directionCount > DIRECTION_THRESHOLD){
    		lib_direction = 1;
    	}
    	else if(directionCount < DIRECTION_THRESHOLD * (-1)){
    		lib_direction = -1;
    	}
    }
}
\end{lstlisting}
\end{minipage}

Aside from determining the direction, the turret also needs to determine at
which speed it should rotate to match the target. This is calculated in the
\textbf{\textit{GetSpeed method}}, as shown in \autoref{GetZeSpeed}. This method
takes the pixel count between the center of the camera and the blob, and outputs
the resulting rotating speed. The sine function maps the 144 pixel width of the
camera to 90 degrees for a sine function. This way the speed should follow a
sine curve, and as such should get slower the closer to the target, and faster
the farther away.

\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[caption = Determine speed to rotate using a sine function, label = GetZeSpeed] 
float GetSpeed(int bcenter){
    int length = bcenter - CAM_CENTER;
    float lib_speed = sind(1.25*length)*100;
    return lib_speed;
}
\end{lstlisting}
\end{minipage}

In conclusion, the tracking phase consists of reading input from the camera, and
using this data to track the target. This is done by determining the targets
direction, and using a sine function to map the pixel-difference in blob
positions to a respective rotational speed.