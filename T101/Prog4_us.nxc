#include "TurretLib.nxc"
#include "nxtcamlib-default.nxc"
#include "TargetPrediction/CalcFPos.nxc"
#define CAMADDR 0x02
#define NAME "Data.dat"

const int dataSetsNeeded = 3;
const int MaxCounterToPurgeData = 40;
int SIZE  = 2048;
bool firstPos = true;
bool first = true;
task search();
task shoot();
task GetLength();
void GroupData();
bool shouldFire = false;
PosData data[100];
int dataCounter = 0;
PosData resData[5];
int resDataCounter = 0;

task main(){
  PosRegEnable(angleMotor);
  SetMotorRegulationTime(100);

  int init = NXTCam_Init(camPort, CAMADDR);
  NXTCam_SendCommand(camPort, CAMADDR, 'A');
  NXTCam_SendCommand(camPort, CAMADDR, 'E');
  SetSensorUltrasonic(sensorLeft);
  SetSensorUltrasonic(sensorRight);
  unsigned int rtn_code = CreateFile(NAME, SIZE, handle);
    if (rtn_code == LDR_FILEEXISTS)
     rtn_code = OpenFileAppend(NAME, SIZE, handle);
     string t =  NumToStr(MotorRotationCount(rotateMotor));
     WriteLn(handle, t);
  Precedes(search,GetLength);
}

task GetLength(){
    string input;
    int length;
    while(true){
        //ClearScreen();
        //NumOut(0,0,counter);
    //if(ButtonPressed(BTNCENTER,false))
        //CloseFile(handle);
        
        if(shouldFire){
            WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
            int right = SensorUS(sensorRight);
            WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);

            WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
            int left = SensorUS(sensorLeft);
            WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);
            
            length = CheckLength(right,left);
            if(length != -1){
                data[dataCounter] = makePosData(length,MotorRotationCount(rotateMotor)*0.73,CurrentTick());
                dataCounter++;
                GroupData();

                if(resDataCounter == dataSetsNeeded){


                    /*directionVector ds[5];
                    int dCounter = 0;
                    directionVector d = calcDirVector(resData,resDataCounter);
                    fireData fire = calcFireData(calcFuturePos(d,500));
                    StopTask(search);
                    TurnTurret(fire.angleH);
                    Angle(fire.angleV);
                    LoadRound();
                    Fire(); */


                    for(int i=0; i < resDataCounter; i++){
                            input = "xPos " + NumToStr(resData[i].xPos) + ", yPos "+ NumToStr(resData[i].yPos)+ ", time " + NumToStr(resData[i].time) + ", angle " + NumToStr(resData[i].angle) + ", group " + NumToStr(resData[i].group);
                            WriteLn(handle, input);
                    }

                    //input = "angleH " + NumToStr(fire.angleH) + ", angleV "+ NumToStr(fire.angleV)+ ", time to hit " + NumToStr(fire.timeToHit) + ", time " + NumToStr(CurrentTick()) + ", speed" + NumToStr(d.speed) + "\n";
                    //WriteLn(handle, input);
                    CloseFile(handle);
                }
            }
        }
    }

}

void GroupData(){
    PosData tempData[20];
    int tempDataCounter = 0;
    int current = -1;
    bool goodData = false;
    for(int i = 0; i < dataCounter; i++){
        int temp = data[i].group;
        if(current != -1 && current == temp){
          if(!data[i].used){
                tempData[tempDataCounter] = data[i];
                tempDataCounter++;
                data[i].used = true;
          }
        }
        else if(current == -1){
            if(!data[i].used){
                current = temp;
                tempData[tempDataCounter] = data[i];
                tempDataCounter++;
                data[i].used = true;
            }
        }
        else{
            goodData = true;
            break;
        }
    }
    
    float combinedYPos = 0;
    float combinedXPos = 0;
    int group = 0;
    
    if(tempDataCounter > 0){
        for(int i = 0; i < tempDataCounter; i++){
            combinedXPos += tempData[i].xPos;
            combinedYPos += tempData[i].yPos;
            group = tempData[i].group;
        }
        
        resData[resDataCounter].yPos = combinedYPos / tempDataCounter;
        resData[resDataCounter].xPos = combinedXPos / tempDataCounter;
        resData[resDataCounter].angle = tempData[0].angle;
        resData[resDataCounter].time = tempData[0].time;
        resData[resDataCounter].group = group;
        resDataCounter++;
    }
    
}

task search(){
  int bt[10];
  int bl[10];
  int bc[10];
  int bb[10];
  int br[10];
  int nblobs;
  int counter = 0;

  while(true){
    NXTCam_GetBlobs(camPort, CAMADDR, nblobs, bc, bl, bt, br, bb);
    if(nblobs > 0){
        if(first){
          Wait(500);
          first = false;
        }
        counter = 0;
      int center = (bl[0] + UpperBound(br[0]))/2;
      OnFwd(rotateMotor, GetSpeed(center));
      shouldFire = true;
    }
    else{
      counter++;
      if(counter == MaxCounterToPurgeData){
            currentAngle = 0;
            currentGroup = 0;
            counter = 0;
            data =  NULL;
            dataCounter = 0;
            resData = NULL;
            resDataCounter = 0;
            first = true;
      }

      Off(rotateMotor);
      shouldFire = false;
    }
  }
}
