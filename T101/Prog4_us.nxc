#include "TurretLib.nxc"
#include "nxtcamlib-default.nxc"
#include "TargetPrediction/CalcFPos.nxc"
#define CAMADDR 0x02
#define NAME "Data.dat"

const int dataSetsNeeded = 3;
const int MaxCounterToPurgeData = 40;
int SIZE  = 2048;
bool first = true;
task search();
task GetLength();
task waitAndFire();
bool shouldFire = false;
PosData data[100];
int dataCounter = 0;
fireData fire;
bool stopFire = false;

task main(){
  PosRegEnable(angleMotor);
  SetMotorRegulationTime(10);
  PosRegEnable(rotateMotor);
  int init = NXTCam_Init(camPort, CAMADDR);
  NXTCam_SendCommand(camPort, CAMADDR, 'A');
  NXTCam_SendCommand(camPort, CAMADDR, 'E');
  SetSensorUltrasonic(sensorLeft);
  SetSensorUltrasonic(sensorRight);
  unsigned int rtn_code = CreateFile(NAME, SIZE, handle);
    if (rtn_code == LDR_FILEEXISTS)
     rtn_code = OpenFileAppend(NAME, SIZE, handle);
  Precedes(search,GetLength);
}

task GetLength(){
    string input;
    int length;
    while(true){
        if(shouldFire){
            WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
            int right = SensorUS(sensorRight);
            WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);

            WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
            int left = SensorUS(sensorLeft);
            WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);
            
            length = CheckLength(right,left);
            if(length != -1){
                PosData temp;
                if(makePosData(length,MotorRotationCount(rotateMotor)*0.73,CurrentTick(),temp)){
                    data[dataCounter] = temp;
                    dataCounter++;
                }

                if(dataCounter == dataSetsNeeded){
                    StopTask(search);
                    directionVector d = calcDirVector(data,dataCounter);
                    fire = calcFireData(calcFuturePos(d,2000));
                    NumOut(0,0,fire.angleH);
                    LoadRound();
                    Rotate(fire.angleH);
                    Angle(fire.angleV);
                    StartTask(waitAndFire);
                    /*for(int i=0; i < dataCounter; i++){
                            input = "xPos " + NumToStr(data[i].xPos) + ", yPos "+ NumToStr(data[i].yPos)+ ", time " + NumToStr(data[i].time) + ", angle " + NumToStr(data[i].angle) + ", group " + NumToStr(data[i].group);
                            WriteLn(handle, input);
                    }
                    input = "angleH " + NumToStr(fire.angleH) + ", angleV "+ NumToStr(fire.angleV)+ ", time to hit " + NumToStr(fire.timeToHit) + ", time " + NumToStr(CurrentTick()) + ", speed" + NumToStr(d.speed) + "\n";
                    WriteLn(handle, input);
                    CloseFile(handle);
                    */
                }
            }
        }
    }

}

task waitAndFire(){
 StopTask(GetLength);
    while(!stopFire){
        if(CurrentTick() >= fire.timeToHit){
            Fire();
            stopFire = true;
        }
    }
    CloseFile(handle);
}

task search(){
  int bt[10];
  int bl[10];
  int bc[10];
  int bb[10];
  int br[10];
  int nblobs;
  int counter = 0;

  while(true){
    NXTCam_GetBlobs(camPort, CAMADDR, nblobs, bc, bl, bt, br, bb);
    if(nblobs > 0){
        if(first){
          Wait(1000);
          first = false;
        }
        else{
            counter = 0;
            int center = (bl[0] + UpperBound(br[0]))/2;
            OnFwd(rotateMotor, GetSpeed(center));
            shouldFire = true;
      }
    }
    else{
      counter++;
      if(counter == MaxCounterToPurgeData){
            currentAngle = 0;
            currentGroup = 0;
            counter = 0;
            data =  NULL;
            dataCounter = 0;
            first = true;
      }

      Off(rotateMotor);
      shouldFire = false;
    }
  }
}
