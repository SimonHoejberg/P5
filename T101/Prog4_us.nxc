#include "TurretLib.nxc"
#include "nxtcamlib-default.nxc"
#include "TargetPrediction/CalcFPos.nxc"
#define CAMADDR 0x02
#define NAME "Data.dat"
const int MaxCounterToPurgeData = 40;
int SIZE  = 2048;
bool firstPos = true;
bool first = true;
task search();
task shoot();
task GetLength();
void GroupData();
bool shouldFire = false;
int counter = 0;
PosData data[100];
int dataCounter = 0;
PosData resData[5];
int resDataCounter = 0;

task main(){
  PosRegEnable(angleMotor);
  SetMotorRegulationTime(100);

  int init = NXTCam_Init(camPort, CAMADDR);
  NXTCam_SendCommand(camPort, CAMADDR, 'A');
  NXTCam_SendCommand(camPort, CAMADDR, 'E');
  SetSensorUltrasonic(sensorLeft);
  SetSensorUltrasonic(sensorRight);
  /*unsigned int rtn_code = CreateFile(NAME, SIZE, handle);
    if (rtn_code == LDR_FILEEXISTS)
     rtn_code = OpenFileAppend(NAME, SIZE, handle);*/
  Precedes(search,GetLength);
}

bool Rotate(){

    int newAngle, check, i;

    for(i = 0; i < 3; i++){
        WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
        int right = SensorUS(sensorRight);
        WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);

        WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
        int left = SensorUS(sensorLeft);
        WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);

        check = CheckLength(right, left);
        if(check != -1){
          newAngle = GetAngle(check);
          Angle(newAngle);
          return true;
        }
    }
    return false;
}

task GetLength(){
    string input;
    int length;
    while(true){
        ClearScreen();
        NumOut(0,0,counter);
    //if(ButtonPressed(BTNCENTER,false))
        //CloseFile(handle);
        
        if(shouldFire){
            WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
            int right = SensorUS(sensorRight);
            WriteI2CRegister(sensorRight, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);

            WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_CONTINUOUS);
            int left = SensorUS(sensorLeft);
            WriteI2CRegister(sensorLeft, I2C_ADDR_DEFAULT, I2C_REG_CMD, US_CMD_OFF);
            
            length = CheckLength(right,left);
            if(length != -1){
                data[dataCounter] = makePosData(length,MotorRotationCount(rotateMotor)*0.73,CurrentTick());
                dataCounter++;
                GroupData();

                if(resDataCounter == 3){
                    directionVector ds[5];
                    int dCounter = 0;
                    directionVector d = calcDirVector(resData,resDataCounter);
                    fireData fire = calcFireData(calcFuturePos(d,500));
                    StopTask(search);
                    TurnTurret(fire.angleH);
                    Angle(fire.angleV);
                    LoadRound();
                    Fire();
                    //input = "angleH " + NumToStr(fire.angleH) + ", angleV "+ NumToStr(fire.angleV)+ ", time to hit " + NumToStr(fire.timeToHit) + ", time " + NumToStr(CurrentTick()) + ", speed" + NumToStr(d.speed) + "\n";
                    //WriteLn(handle, input);
                }
            }
        }
    }

}

void GroupData(){
    PosData tempData[20];
    int tempDataCounter = 0;
    int current = -1;
    bool goodData = false;
    for(int i = 0; i < dataCounter; i++){
        int temp = data[i].group;
        if(current != -1 && current == temp){
          if(!data[i].used){
                tempData[tempDataCounter] = data[i];
                tempDataCounter++;
                data[i].used = true;
          }
        }
        else if(current == -1){
            if(!data[i].used){
                current = temp;
                tempData[tempDataCounter] = data[i];
                tempDataCounter++;
                data[i].used = true;
            }
        }
        else{
            goodData = true;
            break;
        }
    }
    
    float combinedYPos = 0;
    float combinedXPos = 0;
    
    if(tempDataCounter > 0){
        for(int i = 0; i < tempDataCounter; i++){
            combinedXPos += tempData[i].xPos;
            combinedYPos += tempData[i].yPos;
        }
        
        resData[resDataCounter].yPos = combinedYPos / tempDataCounter;
        resData[resDataCounter].xPos = combinedXPos / tempDataCounter;
        resData[resDataCounter].angle = tempData[0].angle;
        resData[resDataCounter].time = tempData[0].time;
        resDataCounter++;
    }
    
}
 
task shoot(){
    while(true){
        LoadRound();
        if(shouldFire && Rotate()){
            Fire();
        }
    }
}

task search(){
  int bt[10];
  int bl[10];
  int bc[10];
  int bb[10];
  int br[10];
  int nblobs;
  int counter = 0;

  while(true){
    NXTCam_GetBlobs(camPort, CAMADDR, nblobs, bc, bl, bt, br, bb);
    if(nblobs > 0){
        if(first){
          Wait(500);
          first = false;
        }
        counter = 0;
      int center = (bl[0] + UpperBound(br[0]))/2;
      OnFwd(rotateMotor, GetSpeed(center));
      shouldFire = true;
    }
    else{
      counter++;
      if(counter == MaxCounterToPurgeData){
            currentAngle = 0;
            currentGroup = 0;
            counter = 0;
            data =  NULL;
            dataCounter = 0;
            resData = NULL;
            resDataCounter = 0;
      }

      Off(rotateMotor);
      first = true;
      shouldFire = false;
    }
  }
}
