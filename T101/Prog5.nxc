#include "TurretLib.nxc"
#include "nxtcamlib-default.nxc"
#include "TargetPrediction/CalcFPos.nxc"
#define CAMADDR 0x02
#define NAME "Data.dat"

const int pixelWidth = 148;
const int dataSetsNeeded = 2;
const int MaxCounterToPurgeData = 150;
int SIZE  = 2048;
bool first = true;
task search();
task GetLength();
task waitAndFire();
bool shouldFire = false;
PosData data[100];
int dataCounter = 0;
fireData fire;
bool stopFire = false;
bool track = true;
bool sampling = true;


task main(){
    PosRegEnable(rotateMotor);
    PosRegEnable(angleMotor);
    SetMotorRegulationTime(10);
    int init = NXTCam_Init(camPort, CAMADDR);
    NXTCam_SendCommand(camPort, CAMADDR, 'A');
    NXTCam_SendCommand(camPort, CAMADDR, 'E');
    SetSensorUltrasonic(sensorLeft);
    SetSensorUltrasonic(sensorRight);
    unsigned int rtn_code = CreateFile(NAME, SIZE, handle);
    if (rtn_code == LDR_FILEEXISTS)
        rtn_code = OpenFileAppend(NAME, SIZE, handle);
    Precedes(search,GetLength);
}

task GetLength(){
    string input;
    int length;
    while(sampling){
        if(shouldFire){
            length = GetDistance();
            if(length != -1){
                PosData temp;
                if(makePosData(length,MotorRotationCount(rotateMotor)*0.73,CurrentTick(),temp)){
                    PlaySound(SOUND_LOW_BEEP);
                    data[dataCounter] = temp;
                    dataCounter++;
                }

                if(dataCounter == dataSetsNeeded){
                    track = false;
                     //for(int i=0; i < dataCounter; i++){
                           // input = "xPos " + NumToStr(data[i].xPos) + ", yPos "+ NumToStr(data[i].yPos)+ ", time " + NumToStr(data[i].time) + ", angle " + NumToStr(data[i].angle) + ", group " + NumToStr(data[i].group);
                            //WriteLn(handle, input);
                    //}
                    directionVector d = calcDirVector(data,dataCounter);
                    fire = calcFireData(calcFuturePos(d,1500));
                    //input = "angleH " + NumToStr(fire.angleH) + ", angleV "+ NumToStr(fire.angleV)+ ", time to hit " + NumToStr(fire.timeToHit) + ", time " + NumToStr(CurrentTick());
                    //WriteLn(handle, input);
                    StartTask(waitAndFire);
                }
            }
        }
    }

}

task waitAndFire(){
    sampling = false;
    LoadRound();
    Off(rotateMotor);
    int angleH = fire.angleH;
    RotateH(angleH);
    Wait(150);
    Angle(fire.angleV);
    while(!stopFire){
        if(CurrentTick() >= fire.timeToHit){
            Fire();
            stopFire = true;
        }
    }
    CloseFile(handle);
    Angle(0);
    while(true){

    }
}

task search(){
    int bt[10];
    int bl[10];
    int bc[10];
    int bb[10];
    int br[10];
    int nblobs;
    int counter = 0;
    int oldCenter;
    int direction = 0; // [-1]Left, [1]Right, [0]Nothing
    int directionCount = 0; //How many times have we seen movement in a direction
    int directionThreshold = 15; //Nr of frames where target has moved in a direction

    while(track){
        NXTCam_GetBlobs(camPort, CAMADDR, nblobs, bc, bl, bt, br, bb);
        if(nblobs > 0){
            shouldFire = true;
            counter = 0;
            oldCenter = center;
            int center = (bl[0] + UpperBound(br[0]))/2;
            Off(rotateMotor);
            OnFwd(rotateMotor, GetSpeed(center));
        }else{
            shouldFire = false;
            counter++;
            if(counter == MaxCounterToPurgeData){
                currentAngle = 0;
                currentGroup = 0;
                counter = 0;
                data =  NULL;
                dataCounter = 0;
                first = true;
                speed = 0;
                Off(rotateMotor);
                directionCount = 0;
            }
        }
        //If direction not found. Check if blob-center has moved left/right for directionTreshold * frames
        if(direction != 0){
            //Check what direction the target is moving
            if(center > oldCenter){
                directionCount++;
            }
            else if (center < oldCenter) {
                directionCount--;
            }
            //Set direction if count above threshold
            if(directionCount > directionThreshold){
                direction = 1;
            }
            else if(directionCount < directionThreshold * (-1)){
                direction = -1;
            }
        }
    }
  Off(rotateMotor);
}
