const float muzzleSpeed = 4.82; //meters per second
const float gravConst = 9.82; //meters per second squared
const int angleToGroup = 8;
float currentAngle = 0;
int currentGroup = 0;


struct PosData {
   int dataID;
   float xPos;
   float yPos;
   unsigned long time;
   float angle;
   int group;
   bool used;
};

struct fireData {
   float angleH;
   float angleV;
   float timeToHit;
};

struct ResData {
   int horizontalAngle;
   int verticalAngle;
   unsigned long timeStamp;
   int fireingDeadline;
};

struct directionVector {
   float speedX;
   float speedY;
};


bool makePosData(int length, float angle, unsigned int time, PosData &pos){
    bool result = false;
    pos.xPos = length*sind(angle);
    pos.yPos = length*cosd(angle);
    pos.time = time;
    pos.angle = angle;
    if(currentAngle-angleToGroup <= angle && currentAngle+angleToGroup >= angle){
        pos.group = currentGroup;
    }
    else{
        result = true;
        currentAngle = angle;
        currentGroup++;
        pos.group = currentGroup;
    }
    pos.used = false;
    return result;
}


//Method which takes an array of directionVectors and returns the average
directionVector combineVectors(directionVector dirVecArray[], int arrayLength){

   directionVector returnVector;
   float xRes = 0;
   float yRes = 0;

   for (int i = 0; i < arrayLength; i++){
       xRes = xRes + dirVecArray[i].speedX;
       yRes = yRes + dirVecArray[i].speedY;
   }

   returnVector.speedX = xRes / arrayLength;
   returnVector.speedY = yRes / arrayLength;
   
   return returnVector;
}


//Method which takes two positions and returns a direction vector
directionVector calcDirVector(PosData dataArray[],   int length){

   directionVector dirVec;
   int firstVector = 0;
   directionVector resultingVectors[10];
   float xDist;
   float yDist;
   unsigned long tDiff;
   
   for(int i = 0; i < length-1; i++){
        xDist = dataArray[firstVector+1].xPos - dataArray[firstVector].xPos;
        yDist = dataArray[firstVector+1].yPos - dataArray[firstVector].yPos;
        tDiff = dataArray[firstVector+1].time - dataArray[firstVector].time;
        resultingVectors[i].speedX = xDist / tDiff;
        resultingVectors[i].speedY = yDist / tDiff;
        firstVector++;
   }
   
   dirVec = combineVectors(resultingVectors,firstVector);

   return dirVec;
}

PosData calcFuturePos(directionVector vector, unsigned long time){
   PosData futurePosition;
   float tanInput = 0;
   futurePosition.xPos = vector.speedX * time;
   futurePosition.yPos = vector.speedY * time;
   futurePosition.time = CurrentTick() + time;
   tanInput = futurePosition.yPos / futurePosition.xPos;
   if(futurePosition.xPos >= 0)
        futurePosition.angle = 90+(atand(tanInput))*(-1);
   else
        futurePosition.angle = (90-(atand(tanInput))*(-1))*(-1);

    NumOut(0,20,futurePosition.angle);
    NumOut(0,0,futurePosition.xPos);
    NumOut(0,10 ,futurePosition.yPos);
   
   return futurePosition;
}

fireData calcFireData(PosData futurePos){

   fireData returnData;
   returnData.angleH = futurePos.angle;
   float dist = sqrt(pow(futurePos.xPos,2)+pow(futurePos.yPos,2));
   returnData.angleV = abs(0.2573*dist-22.85); //Formel baseret på tendenslinje fra testresultater
   returnData.timeToHit = futurePos.time - ((muzzleSpeed * sind(returnData.angleV) - sqrt(pow(muzzleSpeed,2) * pow(sind(returnData.angleV),2))) / gravConst); //Formel for tid for y=0
   
   return returnData;
}
