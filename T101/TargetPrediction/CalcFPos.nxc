const float muzzleSpeed = 4.82; //meters per second
const float gravConst = 9.92; //meters per second squared

struct PosData {
   int dataID;
   float xPos;
   float yPos;
   int time;
   float angle;
};

struct fireData {
   float angleH;
   float angleV;
   float timeToHit;
};

struct ResData {
   int horizontalAngle;
   int verticalAngle;
   int timeStamp;
   int fireingDeadline;
};

struct directionVector {
   float speedX;
   float speedY;
   float speed;
};


PosData makePosData(int length, float angle, int time){
    PosData pos;
    pos.xPos = length*cosd(angle);
    pos.yPos = length*sind(angle);
    pos.time = time;
    pos.angle = angle;
    return pos;
}


//Method which takes two positions and returns a direction vector
directionVector calcDirVector(PosData data1, PosData data2){
   directionVector dirVec;
   float xDist = data2.xPos - data1.xPos;
   float yDist = data2.yPos - data1.yPos;
   float tDiff = data2.time - data1.time;
   if(tDiff < 0){
       tDiff = (65535 - data1.time) + data2.time;
   }
   
   dirVec.speedX = xDist / tDiff;
   dirVec.speedY = yDist / tDiff;
   dirVec.speed = sqrt((dirVec.speedX * dirVec.speedX + dirVec.speedY * dirVec.speedY)) / tDiff;
   
   
   
   return dirVec;
}

//Method which takes an array of directionVectors and returns the average
directionVector combineVectors(directionVector dirVecArray[]){

   directionVector returnVector;
   int arrayLength = SizeOf(dirVecArray) / SizeOf(returnVector);
   int xRes = 0;
   int yRes = 0;
   int tRes = 0;
   
   for (int i = 0; i < arrayLength; i++){
       xRes = xRes + dirVecArray[i].speedX;
       yRes = yRes + dirVecArray[i].speedY;
       tRes = tRes + dirVecArray[i].speed;
   }

   returnVector.speedX = xRes / arrayLength;
   returnVector.speedY = yRes / arrayLength;
   returnVector.speed = tRes / arrayLength;

   return returnVector;
}

PosData calcFuturePos(directionVector vector, int time){
   PosData futurePosition;
   futurePosition.xPos = vector.speedX * vector.speed * time;
   futurePosition.yPos = vector.speedY * vector.speed * time;
   futurePosition.time = CurrentTick() + time;
   futurePosition.angle = atan((vector.speedY / vector.speedX));
   
   return futurePosition;
}

fireData calcFireData(PosData futurePos){

   fireData returnData;
   returnData.angleH = futurePos.angle;
   returnData.angleV = 57.66666667 - 0.3333333333 * sqrt(39790-15000 * 2.596667) - 2; //Formel baseret på tendenslinje fra tests
   returnData.timeToHit = futurePos.time - ((muzzleSpeed * sin(returnData.angleV) - sqrt(pow(muzzleSpeed,2) * pow(sin(returnData.angleV),2))) / gravConst); //Formel for tid for y=0
   
   return returnData;
}
