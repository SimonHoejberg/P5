const float muzzleSpeed = 4.82; //meters per second
const float gravConst = 9.82; //meters per second squared
const int angleToGroup = 5;
float currentAngle = 0;
int currentGroup = 0;


struct PosData {
   int dataID;
   float xPos;
   float yPos;
   int time;
   float angle;
   int group;
   bool used;
};

struct fireData {
   float angleH;
   float angleV;
   float timeToHit;
};

struct ResData {
   int horizontalAngle;
   int verticalAngle;
   int timeStamp;
   int fireingDeadline;
};

struct directionVector {
   float speedX;
   float speedY;
   float speed;
};


PosData makePosData(int length, float angle, int time){
    PosData pos;
    pos.xPos = length*cosd(angle);
    pos.yPos = length*sind(angle);
    pos.time = time;
    pos.angle = angle;
    if(currentAngle-angleToGroup <= angle || currentAngle+angleToGroup >= angle){
        pos.group = currentGroup;
    }
    else{
        currentAngle = angle;
        currentGroup++;
        pos.group = currentGroup;
    }
    pos.used = false;
    return pos;
}


//Method which takes an array of directionVectors and returns the average
directionVector combineVectors(directionVector dirVecArray[]){

   directionVector returnVector;
   int arrayLength = SizeOf(dirVecArray) / SizeOf(returnVector);
   int xRes = 0;
   int yRes = 0;
   int tRes = 0;

   for (int i = 0; i < arrayLength; i++){
       xRes = xRes + dirVecArray[i].speedX;
       yRes = yRes + dirVecArray[i].speedY;
       tRes = tRes + dirVecArray[i].speed;
   }

   returnVector.speedX = xRes / arrayLength;
   returnVector.speedY = yRes / arrayLength;
   returnVector.speed = tRes / arrayLength;

   return returnVector;
}


//Method which takes two positions and returns a direction vector
directionVector calcDirVector(PosData dataArray[], int length){

   directionVector dirVec;
   int firstVector = 0;
   directionVector resultingVectors[10];
   float xDist;
   float yDist;
   float tDiff;
   
   for(int i = 0; i < length-1; i++){
        xDist = dataArray[firstVector+1].xPos - dataArray[firstVector].xPos;
        yDist = dataArray[firstVector+1].yPos - dataArray[firstVector].yPos;
        tDiff = dataArray[firstVector+1].time - dataArray[firstVector].time;
        if(tDiff < 0){
            tDiff = (65535 - dataArray[firstVector].time) + dataArray[firstVector+1].time;
        }

        resultingVectors[i].speedX = xDist / tDiff;
        resultingVectors[i].speedY = yDist / tDiff;
        resultingVectors[i].speed = sqrt((resultingVectors[i].speedX * resultingVectors[i].speedX + resultingVectors[i].speedY * resultingVectors[i].speedY)) / tDiff;

        firstVector++;
   }
   
   dirVec = combineVectors(resultingVectors);

   return dirVec;
}

PosData calcFuturePos(directionVector vector, int time){
   PosData futurePosition;
   futurePosition.xPos = vector.speedX * vector.speed * time;
   futurePosition.yPos = vector.speedY * vector.speed * time;
   futurePosition.time = CurrentTick() + time;
   futurePosition.angle = atan((vector.speedY / vector.speedX));
   
   return futurePosition;
}

fireData calcFireData(PosData futurePos){

   fireData returnData;
   returnData.angleH = futurePos.angle;
   float dist = sqrt(pow(futurePos.xPos,2)+pow(futurePos.yPos,2));
   returnData.angleV = -0.0006 * pow(dist,2) + 0.0692 * dist + 0.6574;
   //returnData.angleV = 57.66666667 - 0.3333333333 * sqrt(39790-15000 * 2.596667) - 2; //Formel baseret på tendenslinje fra tests
   returnData.timeToHit = futurePos.time - ((muzzleSpeed * sin(returnData.angleV) - sqrt(pow(muzzleSpeed,2) * pow(sin(returnData.angleV),2))) / gravConst); //Formel for tid for y=0
   
   return returnData;
}
